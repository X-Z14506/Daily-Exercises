package first.Day15;

/**
 * Created with Intellij IDEA
 * Description:
 * Users:123
 * Date:2020-12-08
 * Time:23:37
 */

//编写一个函数，将两个数字相加，不得使用+或者其他数字运算符
//给定两个int A 和 B,返回A+B的值
//测试样例 1,2   返回 3

/*
           分析：这又是一道考察发散思维的很有意思的题目。当我们习以为常的东西被限制使用的时候，如何突破常规去思考，就是解决这个问题的关键所在。
        看到的这个题目，首先我们可以分析人们是如何做十进制的加法的，比如是如何得出5+17=22这个结果的。
        实际上，我们可以分成三步的：
        第一步只做各位相加不进位，此时相加的结果是12（个位数5和7相加不要进位是2，十位数0和1相加结果是1）；
        第二步做进位，5+7中有进位，进位的值是10；第三步把前面两个结果加起来，12+10的结果是22，刚好5+17=22。
        对数字做运算，除了四则运算之外，也就只剩下位运算了。位运算是针对二进制的，我们也就以二进制再来分析一下前面的三步走策略对二进制是不是也管用。

        5的二进制是101，17的二进制10001。还是试着把计算分成三步：
        第一步各位相加但不计进位，得到的结果是10100（最后一位两个数都是1，相加的结果是二进制的10。这一步不计进位，因此结果仍然是0）；
        第二步记下进位。在这个例子中只在最后一位相加时产生一个进位，结果是二进制的10；
        第三步把前两步的结果相加，得到的结果是10110，正好是22。由此可见三步走的策略对二进制也是管用的。

        接下来我们试着把二进制上的加法用位运算来替代。
        第一步不考虑进位，对每一位相加。0加0与 1加1的结果都0，0加1与1加0的结果都是1。我们可以注意到，这和异或的结果是一样的。
        接着考虑第二步进位，对0加0、0加1、1加0而言，都不会产生进位，只有1加1时，会向前产生一个进位。此时我们可以想象成是两个数先做位与运算，然后再向左移动一位。只有两个数都是1的时候，位与得到的结果是1，其余都是0。
        第三步把前两个步骤的结果相加。如果我们定义一个函数Add（），第三步就相当于输入前两步骤的结果来递归调用自己。
 */
public class Main {
    public static void main(String[] args) {
        int i = 20;
        int j = 98;
        int ret = addAB(i, j);
        System.out.println(ret);
    }

    static int sum = 0;
    static int tmp = 0;

    public static int addAB(int A, int B) {

        if (B == 0) {
            return A;
        } else {
            //第一步，相加不进位
            sum = A ^ B;
            //第二步，求得进位的值
            tmp = (A & B) << 1;
            //第三步，sum和tmp相加
            return addAB(sum, tmp);
        }
    }


    //非递归版：

    /*
     *两个数异或：相当于每一位相加，而不考虑进位；
     *两个数相与，并左移一位：相当于求得进位；
     *将两个新得到的数进行add操作，得到的结果和原本两个数相加相同，
     *这样会把num2变得越来越小，知道为0是，则两个数的和直接就变成num1.
     */

    int Add(int num1, int num2) {
        while (num2 != 0) {
            int temp = num1 ^ num2;
            num2 = (num1 & num2) << 1;
            num1 = temp;
        }
        return num1;

    }
}
